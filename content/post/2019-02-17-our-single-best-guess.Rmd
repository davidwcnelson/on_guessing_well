---
title: Our Single Best Guess
author: WC Telson
date: '2019-02-17'
slug: our-single-best-guess
categories: []
tags:
  - point_estimate
  - estimation
  - proper_scoring
  - central_tendancy
  - mean
  - median
  - mode
---

# Intro

- I wanted to share an insight that relates measures of central tendancy (e.g., mean, median, etc.) to cost functions.

- What is a measure of central tendancy?

- What is a cost function?

- Measures of central tendancy as solutions to variational problems.

# The Guessing Game

- Let's frame our problem as a guessing game.

- Suppose we have a collection of 100 numbered tickets in a hat, where numbers can be repeated and some numbers are more frequent than others.

- We are asked to guess which ticket will be drawn from the hat (we assume that this drawing process is "random"), and we will be awarded points based upon what are guess was and what the actual result was.

- What number should we guess will be drawn next?

- The answer depends entirely on the scoring system.

- Let's explore this example in R.

- First, let's create our collection of 100 tickets. 

```{r, message=FALSE,warning=FALSE,error=FALSE}
# load packages
require('tidyverse')
require('scales')

# set a seed so we can reproduce "random" results
set.seed(1)

# generate 100 samples from a geometric distribution with parameter prob = 1/5
x <- rgeom(n = 100, prob = 1/5)

print(x)
```

- We can get a better intuition of how our tickets are number by plotting them with a bar plot.

```{r}
# create a dot plot of the frequency of each unique value in x
ggplot() +
  geom_bar(aes(x = x)) +
  scale_x_continuous(breaks = seq(min(x),max(x))) + 
  scale_y_continuous(breaks = seq(0,max(table(x)),2)) + 
  labs(x = 'x value', y = 'count of occurances of x value') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
```

- We can see that very few tickets have a value greater than 9, but the most common number for a ticket to have is 0. 

- It seems intuitive at this point that we should guess a number that occurs frequently, as we believe this to be most "likely".

- Note this connection between this notion of "likely" and "frequent", as it is an important relationship we will explore in the future.

- We can also look at this distribution not as counts but as proportions of the whole:

```{r}
ggplot() +
  geom_bar(aes(x = x, ..count../sum(..count..))) +
  scale_x_continuous(breaks = seq(min(x),max(x))) + 
  scale_y_continuous(breaks = seq(0,1,.025), labels = percent) +
  labs(x = 'x value', y = 'count of occurances of x value') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
```



# Mode

- If we were given a penalty for every incorrect guess, i.e. we only win if we guess the exact number of the ticket, what is our best strategy?

- Let's capture this rule in a cost function:

```{r}
# the exact penalty function
exact_penalty <- function(guess, outcome){
  
  as.numeric(guess != outcome)
  
}

# penalty if we guess exactly right
exact_penalty(guess = 5, outcome = 5) 

# penalty if we guess wrong
exact_penalty(guess = 4, outcome = 5) 

# penalty if we are wong by a large amount
exact_penalty(guess = 100, outcome = 5) 
```

- Note that we are penalized the same regardless of whether we are off by a small or large amount i.e. the only thing that matters is that we weren't exactly right.

- Let's use this penalty to examine which guess is best amongst the possible outcomes.

- We can do this by mapping each possible guess to each possible outcome.

```{r}
possible_guesses <- min(x):max(x)

expected_exact_penalty <- map_dbl(possible_guesses, function(current_guess){
  
  exact_penalty(guess = current_guess, outcome = x) %>% mean()
  
})

ggplot() +
  geom_point(aes(x = possible_guesses, y = expected_exact_penalty)) +
  geom_line(aes(x = possible_guesses, y = expected_exact_penalty)) +
  scale_x_continuous(breaks = seq(min(x),max(x))) + 
  scale_y_continuous(breaks = seq(.8,1,.05)) + 
  labs(x = 'x value', y = 'mean exact penalty') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
```

- Note that the expected exact penalty is the compliment of the proportion of all tickets made up by the given ticket number i.e. $1-p_i$ where $p_i$ is the proportion of tickets made up by the $i$th number.

- With that in mind, the guess that minimizes our penalty over any guess is the ticket that makes up the largest proportion i.e. is the most frequent i.e. is the most likely, which consequently is the mode of our tickets.

# Median

What if we gave ourselves some extra credit for guesses that are closer to the outcome? Let's say that our penalty is equal to the absolute difference between our guess and the outcome.

```{r}
# absolute difference penalty
abs_diff_penalty <- function(guess, outcome){
  
  abs(guess - outcome)
  
}

# penalty if we guess exactly right
abs_diff_penalty(guess = 5, outcome = 5) 

# penalty if we guess wrong
abs_diff_penalty(guess = 4, outcome = 5) 

# penalty if we are wong by a large amount
abs_diff_penalty(guess = 100, outcome = 5) 
```

- Now if our guess is further off, we are penalized more than if it is closer. 

- As we did we the exact penalty, let's see which guess minimizes this penalty.

```{r}
possible_guesses <- min(x):max(x)

expected_abs_diff_penalty <- map_dbl(possible_guesses, function(current_guess){
  
  abs_diff_penalty(guess = current_guess, outcome = x) %>% mean()
  
})

ggplot() +
  geom_point(aes(x = possible_guesses, y = expected_abs_diff_penalty)) +
  geom_line(aes(x = possible_guesses, y = expected_abs_diff_penalty)) +
  scale_x_continuous(breaks = seq(min(x),max(x))) + 
  scale_y_continuous(breaks = seq(0,15,1)) +
  labs(x = 'x value', y = 'mean abs diff penalty') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
```

- We see here that the minimum is at 3, which is of course the median of the ticket values i.e. it is the value of the ticket that is in the middle of all tickets when we line them up from smallest to largest value.

# Mean

- We have seen how the mode and the median are natural choices for a guess given a certain penalty system, but where does the mean come into play?

- While the median gives us credit for being close to the actual outcome, we may think that being off by larger and larger amounts is worse and worse i.e. being off by 10 is more than 10x as bad as being off by 1. 

- In this way, we could choose to penalize larger difference more by taking the square of the distances as our penalty.

```{r}
# squared difference penalty
sqr_diff_penalty <- function(guess, outcome){
  
  (guess - outcome)^2
  
}

# penalty if we guess exactly right
sqr_diff_penalty(guess = 5, outcome = 5) 

# penalty if we guess wrong
sqr_diff_penalty(guess = 4, outcome = 5) 

# penalty if we are wong by a large amount
sqr_diff_penalty(guess = 100, outcome = 5) 
```

- Here we can see that a large difference is much much worse than a small difference. 
- Let's find the value that minimizes this penalty.

```{r}
possible_guesses <- seq(min(x),max(x),.01)

expected_sqr_diff_penalty <- map_dbl(possible_guesses, function(current_guess){
  
  sqr_diff_penalty(guess = current_guess, outcome = x) %>% mean()
  
})

ggplot() +
  # geom_point(aes(x = possible_guesses, y = expected_abs_diff_penalty)) +
  geom_line(aes(x = possible_guesses, y = expected_sqr_diff_penalty)) +
  scale_x_continuous(breaks = seq(min(x),max(x))) + 
  # scale_y_continuous(breaks = seq(0,15,1)) +
  labs(x = 'x value', y = 'mean sqr diff penalty') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
```

- here we hit our minimum between 3 and 4, or to be precise the minimum is achieved when we guess 3.32 which is equivalent to the mean.

# Midrange

At this point, we wish to point out a general pattern. All of the aforementioned penalty functions take the general form:
$$|guess - outcome|^p$$
We raise the absolte difference between our guess and outcome to some power $L$. If $p = 1$ then the median is the optimal guess. If $p = 2$ then the mean is the optimal guess. We can interpret the mode as the optimal guess when $p \to 0$. This naturally begs the question: what if $p \to \infty$?

To understand what we mean by this, we should consider what happens to a non-zero, non-unit difference as $p$ gets larger and larger.

```{r}
tibble(p = seq(0,10,.01), d = 5^p) %>%
  ggplot(aes(x = p, y = d)) +
  geom_line() +
  theme_minimal() +
  labs(x = 'p', y = 'penalty')
```

- We can see that as p increases, the penalty assigned to (in this case the number 5) grows exponentially.

- Further, we should note what happens to points that are near eachother when p is very large.

```{r}
tibble(abs_diff = seq(0,100,.01), penalty = abs_diff^10) %>%
  ggplot(aes(x = abs_diff, y = penalty)) +
  geom_line() +
  theme_minimal() +
  labs(x = 'absolute difference', y = 'penalty')
```

- Here we see a similiar pattern, but note what it means: the bigger differences matter exponentially more than smaller differences. As we take $p$ to be larger and larger, the largest difference dwarfs all other differences i.e. the only difference that matters is the biggest one.

- Let's create a penalty function that returns the largest possible difference. Two important notes: A) this penalty function requires that we have an upper and lower limit to our possibilities. This condition is easily met by our current guessing game, but it will become useless when the possibilities extend to negative or positive infinity. B) we cannot define this penalty on a single guess and outcome. We have to know the extremes of our possibilities. 

```{r}
possible_guesses <- seq(min(x),max(x),.01)

expected_max_diff_penalty <- map_dbl(possible_guesses, function(current_guess){
  
  abs_diff_penalty(guess = current_guess, outcome = x) %>% max()
  
})

ggplot() +
  # geom_point(aes(x = possible_guesses, y = expected_abs_diff_penalty)) +
  geom_line(aes(x = possible_guesses, y = expected_max_diff_penalty)) +
  scale_x_continuous(breaks = seq(min(x),max(x))) + 
  # scale_y_continuous(breaks = seq(0,15,1)) +
  labs(x = 'x value', y = 'mean max diff penalty') +
  theme_minimal() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank())
```

- We can see that the minimum is exactly in the middle of our possible values. Specifically, our minimum is the minimum x plus the maximum x divided by 2 i.e. the midrange.






# Aftermath

## Applicability of Measures to Kinds of Data

- Nominal, Ordinal, Interval, Ratio

- Finiteness

- Discreteness

## Proofs



